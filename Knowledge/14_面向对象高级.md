# 面向对象高级

## 代码块（初始化块）

代码块属于类中的成员，是类的一部分，类似于方法，将逻辑语句封装再方法体中，通过{}包围起来。

但是和方法不同，没有方法名，没有返回，没有参数，只有方法体

而且无需显示调用，**在加载类时，或创建对象时隐式调用**

```
基本语法
[修饰符]{
	代码
};
```

注意：

1. 修饰符可选，只能写`static` 
2. 代码块分为两类：static修饰的静态代码块，没修饰的普通/非静态代码块
3. 代码可以为任意逻辑语句，即和方法体内一样
4. `;` 可写，可省略

> IDEA 撤销快捷键`Ctrl + z` 恢复快捷键`Ctrl +Shift +z` 
>
> Windows输入法 切换全角半角`Shift + 空格`

==用处：构造器中重复代码，可以放入代码块中==

==原因：创建对象后，会先调用代码块中的内容，然后才调用构造器。代码块优先于构造器==

相当于构造器的补充机制，可以做初始化操作

### 细节

1. static代码块，即静态代码块，作用就是对类进行初始化，**随着类的加载而执行，只会执行一次**。普通代码块，创建对象时就会执行，可以执行多次。
2. ==**类加载的时间**==
   1. 创建对象实例时
   2. 创建子类对象实例时，父类也会加载
   3. 使用类的静态成员（属性，方法）时
3. 普通的代码块，在创建对象时会被隐式调用，创建一次则调用一次。**如果只是使用类的静态成员时，普通代码块并不会执行，但是静态代码块会执行**
4. **创建一个对象时，在==一个类==的调用顺序**：
   1. 调用**静态代码块和静态属性初始化**`private static int n=getN();` 二者优先级一样，按照定义顺序调用
   2. **调用普通代码块和普通属性初始化** 后面同上
   3. 最后调用构造器
5. 构造器最前面隐含了`super()` 和 `调用普通代码块` 。静态代码块和属性在类加载的时候，就执行完毕，优先于构造器和普通代码块执行的。

```
class DD{
    public DD(){
        //super();
        //调用普通代码块，以及普通属性初始化
        System.out.println("执行构造器");
    }
}
```

6. ==**创建一个子类对象时(extends)，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始，构造器调用顺序**==

   1. 父类的静态代码块和静态属性初始化，优先级一样按照定义顺序执行
   2. 子类的静态代码块和静态属性初始化
   3. 父类的普通代码块和普通属性初始化
   4. 父类的构造方法
   5. 子类的普通代码块和普通属性
   6. 子类的构造方法

   因为静态代码块是加载的时候，与加载顺序有关，与代码无关，其余的可以通过代码理解

   **可以通过其了解加载的顺序，即==先加载父类，再加载子类==。构造器调用父类顺序**
7. **静态代码块只能调用静态成员，普通代码块可以调用任意成员，类似于静态方法**
   
   
   

> 代码块只要放在类里面就可以，顺序无要求

> 对象创建的顺序比较重要

## 单例设计模式

**设计模式**：在大量实践中总结和理论化优选的代码结构、编程风格、以及解决问题的思考方式。

**单例模式**：采取一定的方法，保证整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。--即==**某个类只能有一个实例**== 1，`饿汉式` 2，`懒汉式`

**饿汉式单例模式实现**

1. 构造器私有化=》防止直接new
2. 类的内部创建静态对象，用静态的公共方法初始。静态修饰，才可以在下面使用。其在类加载的时候就只初始化一次，而且只有一次
3. 向外暴露一个静态的公共方法，返回对象。`getInstance`
4. 代码实现，直接通过方法获取对象

**只要类被加载了，例如访问静态变量。对象就自动创建了，不管有没有使用到，可能造成资源浪费**

**懒汉式单例模式实现**

1. 构造器私有化
2. 类的内部创建静态属性对象，不初始化。
3. 向外暴露一个静态的公共方法，首先判断静态变量是否为空，为空则返回创建对象并返回；不空则直接返回对象。`getInstance`
4. 只有用户使用`getInstance` 时才创建。

**类加载了，不直接创建。使用才会创建。不使用就不创建对象**

**VS**

1. 饿汉式在类加载的时候创建对象，懒汉式在使用时才创建
2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题，例如三个线程执行`getInstance`
3. 饿汉式存在资源浪费问题
4. java.lang.Runtime就是单例模式

> IDEA输入Runtime，然后Ctrl+B查看源码

> 设计模式可能还是要单独去学一下

## final关键字

`final` 可以修饰类，属性，方法和局部变量

1. 当不希望父类被继承时，可以用final修饰 `final class A{}`
2. 当不希望父类的某个方法被子类重写，可以使用final修饰 `public final void hi(){}`
3. 当不希望类的某个属性值被修改，变成常量一样了 `public final double sum=20;`
4. 当不希望某个局部变量被修改 `final double num=0.01;` 局部常量

> 重写方法，也可以通过IDEA Generator自动生成

注意事项：

1. final修饰的属性叫做常量，一般用XX_XXX_XXX命名
2. final修饰的属性在定义的时候必须赋初值，并且不能修改。初始值定义位置，三者其一
   1. 在定义时=
   2. 在构造器中
   3. 在普通代码块中
3. final修饰的属性是静态的，则初始化的位置:
   1. 定义时：`public static  final int s1=100;`
   2. 静态代码块中：`static {s2=200;}`
4. final类是不能被继承的，但是可以实例化对象
5. 如果类本身final类的，但是含有final方法，则该方法不能被重写，但是可以被继承，即子类中可以使用。
6. 一般只要类是final的，则方法不用再用final修饰了
7. fianl不能修饰构造方法
8. **final和static往往搭配使用，修饰顺序无要求。这样的效率更高，使用该成员属性时不会导致类加载，底层编译器做了优化处理**
9. 包装类（Integer，Double，Float，Boolean都是final）String也是final类，不能被继承
10. 形参也可以加final `public int addOne(final int x)` 也是不能被修改

## 抽象类

当父类的一些方法不能确定时，可以使用`abstract` 关键字来修饰该方法，这个方法就是抽象方法，还有就是抽象类

父类方法不确定，则将其设计为抽象方法，即没有方法体{}，语法`修饰符 abstract 返回类型，方法名(参数列表);`。

**当一个类中存在抽象方法时，需要将该类声明为抽象类。一般抽象类会被继承，由子类实现抽象方法**

常用于设计模式。

### 细节

1. **抽象类不能被实例化**
2. 抽象类可以没有抽象方法，也可以有普通方法
3. 一个类包含了抽象方法，则类必须为抽象修饰
4. `abstract` 只能修饰类和方法，不能修饰其他的
5. 抽象类可以有任意成员，即抽象类本质还是类。如非抽象方法，构造器，静态属性...
6. 抽象方法不能有方法体`{ }`
7. 一个类如果继承了抽象类，则他必须实现抽象类的所有方法（即在子类中重写），除非他自己也声明为抽象类。
8. 抽象方法不能使用`private` `final` `static` 修饰，因为这些关键字都是和重写相背的。final显然，static关键字与方法重写无关，private修饰的方法不能重写

### 模板模式 

即将类中相似方法的公共部分拿出来，写成一个抽象的类，然后在子类中实现该方法。

```
abstract class Template{    //抽象类
    public abstract void job(); //抽象方法
    public void caculate(){
        long start=System.currentTimeMillis();
        //动态绑定机制，默认调用对应对象的job()函数
        job();
        long end=System.currentTimeMillis();
        System.out.println("执行时间为"+(end-start));
    }
}
```

##　接口Interface

**给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法实现**

就是一些相似的类，实现这个接口，即可以直接通过这个接口作为形参调入，类似于多态，但是又有限制，每个类都要重写接口的方法。

```
接口定义：
interface 接口名{
	//属性
	//方法
}
class 类名 implements 接口{
	自己的属性；
	自己的方法；
	实现的接口的抽象方法
}
```

jdk7以前，接口的方法都是抽象方法。jdk8后接口中可以有方法的具体实现

在接口中，抽象方法可以省略`abstract` 关键字，也可以默认静态方法（用`default` 修饰），还可以静态方法

一个类要实现接口，则需要将该接口的所以抽象方法都实现

注意事项：

1. **接口不能被实例化**
2. **接口中所有的方法是public方法，默认就是public的，可以不写，接口中的抽象方法，可以不用abstract修饰**
3. **一个普通类实现接口，必须把该接口的所有方法都实现，可以用`alt+enter`**
4. 抽象类实现接口，可以不用实现接口的方法
5. **一个类可以同时实现多个接口**
6. **接口中的属性，只能是final的，而且是==public static final==修饰。可以通过接口名称访问：接口名.属性名，也可以通过已实现类的实例来访问，b.a，还可以通过已实现类的类名访问，B.a，不可修改**
7. **接口不能继其他的类，但是可以继承多个别的接口，而且可以不止一个**
8. 接口的修饰符为默认，public。与类的修饰符一样

**接口是对java单继承机制的一种补充，单纯的继承不能够实现多个继承，可以通过实现接口的方式扩展**

**继承价值在于解决代码的复用和可维护性，接口价值在于设计好各种规范（产品经理），更加灵活**

### 接口的多态性

1. 多态参数：形参是接口类型，则可以接收 **实现了该接口的类的对象实例** 。接口类型的引用可以指向实现了接口类的对象！！！`Usb u=new Camera(); u=new Computer();` 类似于继承
2. 多态数组：用`instanceof` 判断其运行类型。即一个接口引用的数组，其每个元素可以指向不同的类
3. 接口多态传递现象：普通类实现了他的接口，以及接口的所有父类接口

区别接口和父类的属性，使用接口名.属性或则super.属性

## 内部类inner class

类的五大成员：属性，方法，构造器，代码块，内部类

内部类：一个类的内部又嵌套了另一个类结构，被嵌套的类被称为内部类。最大特点就是可以直接访问私有属性。

```
基本语法
class Outer{		//外部类
	class Inner{	//内部类
	
	}
}
class Other{		//其他类

}
```

四种内部类

定义在外部类的局部位置（方法内）：

1. 局部内部类（有类名）
2. 匿名类变量（没匿名，重点）

定义在外部类的成员位置上：

1. 成员内部类（没static）
2. 静态内部类（static修饰）

###　局部内部类

局部内部类是定义在外部类的局部位置，比如方法中，并且有类名。

定义在方法中或代码块，其本质是一个类

1. **可以直接访问外部类的所有成员**，包含私有的。
2. 不能添加访问修饰符，因为其相当于是**一个局部变量**。但是其即这个类可以用final修饰，防止被其他的局部内部类继承
3. 作用域：仅仅在定义它的方法或代码块中
4. 局部内部类可以直接访问外部类的成员
5. 在作用域中，可以创建局部内部类对象，然后调用方法
5. 外部其他类不能访问局部内部类，即外部其他类不能创建局部内部类的对象
5. 如果外部类与局部内部类的成员重名时，就近原则，如果想访问外部类的成员`外部类名.this.成员`
5. 外部类名.this就是对应该外部类的某一个调用本方法的对象

### 匿名内部类Anonymous

本质是类，内部类，该类没有名字，同时还是一个对象

```
匿名内部类的基本语法
new 类或接口(参数列表){
	类体
};
```

1. 基于接口的匿名内部类

```
class Outer3{
    private int n1=10;
    public void method(){
        Tiger tiger = new Tiger();
        tiger.cry();
        //使用匿名内部类简化开发，有些类只是使用一次，后面不再使用
        //tig的编译类型为IA
        //tig的运行类型为匿名内部类
        /*底层实现  XXX即外部类名称加$1，系统自动分配
        * class XXX implements IA{
        *  @Override
            public void cry() {
                System.out.println("老虎叫唤");
            }
        *}
        * */
        //jdk底层在创建内部类Outer3$1，立马就创建了Outer3$1的实例
        //并且把地址返回
        //匿名内部类使用一次就不能再使用了
        IA tig=new IA(){
            @Override
            public void cry() {
                System.out.println("老虎叫唤");
            }
        };
        tig.cry();
        System.out.println(tig.getClass());
    }
}
interface IA{
    void cry();
}
class Tiger implements IA{

    @Override
    public void cry() {
        System.out.println("老虎叫唤...");
    }
}
```

2. 基于类的匿名内部类

```
class Outer3{
    private int n1=10;
    public void method(){
        Tiger tiger = new Tiger();
        tiger.cry();
        //1、father编译类型是Father
        //2、father运行类型不是Father，而是匿名内部类
        //3、底层会创建匿名内部类
        /*相当于一个!!!!类继承!!!!!了Father类，并且重写了方法
        * */
        //4、直接返回了匿名内部类的对象
        //5、参数列表传递给原先类的构造器
        //如果是基于抽象类的匿名内部类，则必须实现方法，即重写
        Father father =new Father("jack"){
            @Override
            public void test() {
                System.out.println("匿名内部类重写test方法");
            }
        };
        System.out.println(father.getClass());
        //class com.innerclass.example3.Outer3$2
        father.test();
        //因为重写了，所以可以编译，然后运行的时候是按照其运行类型，如果不重写则可以编译，但是没有效果
    }
}
class Father{
    private String name;

    public Father(String name) {
        this.name = name;
    }

    public void test(){

    }

}
```

3. 匿名内部类是一个类的定义，匿名内部类本身也是返回对象，可以直接调用 `new person(){	}.fun();`
4. 可以访问外部类的所有成员，含私有
5. 不能添加访问修饰符，其本身就是一个局部变量
6. 作用域：仅仅在定义和调用的方法或代码块中
7. 匿名内部类可以直接访问外部类
8. 外部其他类不能访问匿名内部类
9. 重名的话，同局部内部类

应用：

​	1. 当作实参直接传递。**本质上就是简化了重新定义一个类，实现接口，或则继承类。注意一下编译类型与运行类型不同**

> `对象实例.getClass()`获取其运行类型

### 成员内部类

成员内部类定义在外部类的**成员位置**，没有static修饰。本质就是一个成员

1. 可以访问外部类的所有成员

2. 可以添加任意的修饰符，其本质就是一个成员

3. 作用域：与成员一样，外部类都可以使用。可以在外部类创建对象再调用方法

4. 成员内部类可以直接访问外部类的所有成员

5. 外部类访问成员内部类，先创建对象，再调用

6. 其他外部类访问成员内部类

   1. ```
      Outer5.Inner5 inner5=outer5.new Inner5();	//外部类实例new内部类
      inner51.say();
      ```
   2. ```
   Outer5.Inner5 inner52=outer5.getInstance();	//外部类调用方法返回内部类对象

7. 成员重名同理。

### 静态内部类

有static修饰。`static class Inner6`

1. 可以访问外部类的所有**静态成员**，不能访问非静态
2. 可以添加任意的修饰符，其本质就是一个成员
3. 作用域：与成员一样，为整个类体
4. 静态成员内部类可以直接访问外部类的所有**静态成员**
5. 外部类访问静态成员内部类，先创建对象，再调用
6. 其他外部类访问静态内部类。即相当于类名为Outer6.Inner6
   1. ​	`Outer6.Inner6 inner6 = new Outer6.Inner6();`
   2. `Outer6.Inner6 inner61 = new Outer6().getInstance();`
7. 如果外部类与局部内部类的成员重名时，就近原则，如果想访问外部类的成员`外部类名.成员`

