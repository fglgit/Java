# 面向对象高级

## 代码块（初始化块）

代码块属于类中的成员，是类的一部分，类似于方法，将逻辑语句封装再方法体中，通过{}包围起来。

但是和方法不同，没有方法名，没有返回，没有参数，只有方法体

而且无需显示调用，**在加载类时，或创建对象时隐式调用**

```
基本语法
[修饰符]{
	代码
};
```

注意：

1. 修饰符可选，只能写`static` 
2. 代码块分为两类：static修饰的静态代码块，没修饰的普通/非静态代码块
3. 代码可以为任意逻辑语句，即和方法体内一样
4. `;` 可写，可省略

> IDEA 撤销快捷键`Ctrl + z` 恢复快捷键`Ctrl +Shift +z` 
>
> Windows输入法 切换全角半角`Shift + 空格`

==用处：构造器中重复代码，可以放入代码块中==

==原因：创建对象后，会先调用代码块中的内容，然后才调用构造器。代码块优先于构造器==

相当于构造器的补充机制，可以做初始化操作

### 细节

1. static代码块，即静态代码块，作用就是对类进行初始化，**随着类的加载而执行，只会执行一次**。普通代码块，创建对象时就会执行，可以执行多次。
2. ==**类加载的时间**==
   1. 创建对象实例时
   2. 创建子类对象实例时，父类也会加载
   3. 使用类的静态成员（属性，方法）时
3. 普通的代码块，在创建对象时会被隐式调用，创建一次则调用一次。**如果只是使用类的静态成员时，普通代码块并不会执行，但是静态代码块会执行**
4. **创建一个对象时，在==一个类==的调用顺序**：
   1. 调用**静态代码块和静态属性初始化**`private static int n=getN();` 二者优先级一样，按照定义顺序调用
   2. **调用普通代码块和普通属性初始化** 后面同上
   3. 最后调用构造器
5. 构造器最前面隐含了`super()` 和 `调用普通代码块` 。静态代码块和属性在类加载的时候，就执行完毕，优先于构造器和普通代码块执行的。

```
class DD{
    public DD(){
        //super();
        //调用普通代码块，以及普通属性初始化
        System.out.println("执行构造器");
    }
}
```

6. ==**创建一个子类对象时(extends)，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始，构造器调用顺序**==

   1. 父类的静态代码块和静态属性初始化，优先级一样按照定义顺序执行
   2. 子类的静态代码块和静态属性初始化
   3. 父类的普通代码块和普通属性初始化
   4. 父类的构造方法
   5. 子类的普通代码块和普通属性
   6. 子类的构造方法

   因为静态代码块是加载的时候，与加载顺序有关，与代码无关，其余的可以通过代码理解

   **可以通过其了解加载的顺序，即==先加载父类，再加载子类==。构造器调用父类顺序**
7. **静态代码块只能调用静态成员，普通代码块可以调用任意成员，类似于静态方法**
   
   
   

> 代码块只要放在类里面就可以，顺序无要求

> 对象创建的顺序比较重要

## 单例设计模式

**设计模式**：在大量实践中总结和理论化优选的代码结构、编程风格、以及解决问题的思考方式。

**单例模式**：采取一定的方法，保证整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。--即==**某个类只能有一个实例**== 1，`饿汉式` 2，`懒汉式`

**饿汉式单例模式实现**

1. 构造器私有化=》防止直接new
2. 类的内部创建静态对象，用静态的公共方法初始。静态修饰，才可以在下面使用。其在类加载的时候就只初始化一次，而且只有一次
3. 向外暴露一个静态的公共方法，返回对象。`getInstance`
4. 代码实现，直接通过方法获取对象

**只要类被加载了，例如访问静态变量。对象就自动创建了，不管有没有使用到，可能造成资源浪费**

**懒汉式单例模式实现**

1. 构造器私有化
2. 类的内部创建静态属性对象，不初始化。
3. 向外暴露一个静态的公共方法，首先判断静态变量是否为空，为空则返回创建对象并返回；不空则直接返回对象。`getInstance`
4. 只有用户使用`getInstance` 时才创建。

**类加载了，不直接创建。使用才会创建。不使用就不创建对象**

**VS**

1. 饿汉式在类加载的时候创建对象，懒汉式在使用时才创建
2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题，例如三个线程执行`getInstance`
3. 饿汉式存在资源浪费问题
4. java.lang.Runtime就是单例模式

> IDEA输入Runtime，然后Ctrl+B查看源码

> 设计模式可能还是要单独去学一下

## final关键字

`final` 可以修饰类，属性，方法和局部变量

1. 当不希望父类被继承时，可以用final修饰 `final class A{}`
2. 当不希望父类的某个方法被子类重写，可以使用final修饰 `public final void hi(){}`
3. 当不希望类的某个属性值被修改，变成常量一样了 `public final double sum=20;`
4. 当不希望某个局部变量被修改 `final double num=0.01;` 局部常量

> 重写方法，也可以通过IDEA Generator自动生成

注意事项：

1. final修饰的属性叫做常量，一般用XX_XXX_XXX命名
2. final修饰的属性在定义的时候必须赋初值，并且不能修改。初始值定义位置，三者其一
   1. 在定义时=
   2. 在构造器中
   3. 在普通代码块中
3. final修饰的属性是静态的，则初始化的位置:
   1. 定义时：`public static  final int s1=100;`
   2. 静态代码块中：`static {s2=200;}`
4. final类是不能被继承的，但是可以实例化对象
5. 如果类本身final类的，但是含有final方法，则该方法不能被重写，但是可以被继承，即子类中可以使用。
6. 一般只要类是final的，则方法不用再用final修饰了
7. fianl不能修饰构造方法
8. **final和static往往搭配使用，修饰顺序无要求。这样的效率更高，使用该成员属性时不会导致类加载，底层编译器做了优化处理**
9. 包装类（Integer，Double，Float，Boolean都是final）String也是final类，不能被继承
10. 形参也可以加final `public int addOne(final int x)` 也是不能被修改

## 抽象类

当父类的一些方法不能确定时，可以使用`abstract` 关键字来修饰该方法，这个方法就是抽象方法，还有就是抽象类

父类方法不确定，则将其设计为抽象方法，即没有方法体{}。

**当一个类中存在抽象方法时，需要将该类声明为抽象类。一般抽象类会被继承，由子类实现抽象方法**

