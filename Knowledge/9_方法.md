## 成员方法传参机制parameter参数

调用成员方法时，会在栈中创建一个新的独立空间，用于存放形参，以及中间变量

传入实参数，独立空间内有位置存放该形参，内部和外部的变量相互独立

==**如果传递的是基本数据类型，则方法内外的变量相互独立**==

==**基本数据类型，传递的是值，形参的改变不影响实参**==

> Math.random()返回值是double类型，而且是0~1内的数
>
> 关于简单的换行，则需要通过行数序号确定

传入引用数据类型，实参和形参都在栈中占用内存空间，但是其值都是指向同一块堆的内存单元

==**如果传递的是引用数据类型(数组，类)，则方法内外变量同一**==

==**引用类型传递的是地址，就是值是地址，可以通过形参影响实参**==

如果形参为类class，则可以直接在方法内操作，而无需创建一个该类型的对象

```
class Person{
	String name;
}
class B{
	public void test(Person p){
		p.age=1000;
	}
}
```

> 通过输出对象的hashcode判断是否为同一个对象，也可以通过**直接判断p1==p2**，虽然属性相同，但是在内存中互相独立

## 方法递归recursion调用机制

在递归调用的过程中，不断创建独立的内存空间

1. 执行一个方法时，就创建一个新的收保护的独立空间
2. 方法内的局部变量独立，但是引用变量会共享
3. 递归必须有退出条件，否则栈溢出StackOverflowError
4. 谁调用，谁返回，编译原理控制链

//递归寻路，不同的顺序有不同的结果

> 字符常量必须带单引号，否则无法识别

## 方法重载OverLoad

**java中允许同一个类中，多个同名的方法存在，但是要求形参列表不一致，顺序，类型等等**

例如System.out.println()，该方法可以传递不同的实参。out是一个对象

1. 方法名必须相同
2. 形参列表必须不同（类型，个数或者顺序，**参数名和返回类型**没有要求（即不能只要参数名不同，也不能只有返回类型不同）即只有形参列表所对应的类型列表不同才行

重载也可以进行自动类型转换，但是先去找可以直接匹配的方法，如果没有找到可以直接匹配，则自动类型转换了

## 可变参数Variable parameters

**java允许将同一个类中多个同名同功能的但参数个数不同的方法，封装成一个方法**

例如n个参数的和

```
//int... 表示接受的是可变参数，即可以接收多个参数0-多
//使用可变参数可以当作数组使用
public int sum(int... nums){
	System.out.println("参数个数为："+nums.length);
	int sum=0;
	for(int i=0;i<nums.length;i++){
		sum+=nums[i];
	}
	return sum;
}
```

1. 可变参数的实参可以是0个或任意多个
2. 可变参数的实参可以是数组
3. ==可变参数本质是数组==
4. **可变参数可以和普通类型的参数一起放在形参列表，但是必须保证可变参数在最后**
5. **形参列表最多出现一个可变参数**

## 作用域

1. java中，主要变量就是属性（成员变量）和局部变量
2. 局部变量一般是指在成员方法中定义的变量
3. java中作用域分类：全局变量作用域为整个类体，局部变量作用域为定义的代码块中
4. 全局变量可以不赋值，直接使用，因为其有默认值（属性有默认值），也可以在定义的时候直接赋值。局部变量必须赋值后，才可以使用，没有默认值

细节：

1. 属性和局部变量变量可重名，遵循就近原则
2. 在同一个作用域中，变量不能重名，否则重定义报错
3. 属性生命周期长，伴随对象创建和销毁，局部变量属性短，伴随代码块，用完就销毁了
4. 作用域范围不同：全局变量可以在本类使用，也可以在其他类使用（1、所在类传入其他类方法的参数列表中；2、在其他类方法中创建对象再访问）
5. 全局变量可以加修饰符，局部变量不行

## 构造器/构造方法constructor

在创建对象时，直接指定对象属性的值。

构造器是类的一种特殊的方法，主要作用是完成对新对象的初始化。**先产生对象，然后再由构造器初始化**

```
//基本语法
[修饰符] 方法名(形参列表){
	方法体;
}
```

1. 构造器没有返回值
2. 方法名必须和类名一样
3. 参数列表和成员方法规则一样
4. 构造器的调用由系统完成，在创建对象时，系统会自动调用该类的构造器完成初始化

例子

```
public class Constructor{
	public static void main(String[] args){
		Person p=new Person("Smith",80);
		System.out.println("姓名："+p.name+" 年龄："+p.age);
	}
}
class Person{
	String name;
	int age;
	//构造器没有返回值，也不是void
	//构造器名称和类一样
	//形参列表和成员方法一样
	public Person(String pname,int page){
		System.out.println("构造器被调用~此时对象已经初始化了");
		name=pname;
		age=page;
	}
}
```

使用细节：

1. 一个类可以定义多个构造器，即构造器重载
2. 构造器必须和类名相同
3. 构造器没有返回值
4. 构造器是完成对象初始化，不是创建对象
5. **创建对象时，系统自动调用该类的构造方法**
6. 程序员如果没有定义构造器，系统会自动给类生成一个默认无参构造器例如`Person(){}`，通过`javap`反编译查看
7. 一旦定义自己的构造器，默认的构造器就被赋给了，就不能直接new dog()了，除非显式定义一次

> 反编译`javap *.class`，可以获得源文件

> 如果字符串为空也可以输出，得到null

## 对象创建的流程分析

1. 首先在方法区中加载person类，只会加载一次
2. 在堆里面开辟空间，1、默认初始化（默认值），再2、显示初始化
3. 再通过3、构造器初始化，参数如果为字符串常量，则在方法区的常量池中存储
4. 最后把堆中的地址给栈中的p赋值

![image-20240814150946631](C:\Users\F\AppData\Roaming\Typora\typora-user-images\image-20240814150946631.png)

## this关键字

java虚拟机会给每个对象分配this，代表当前对象，类似于“我的”

使用this，使得构造器的参数不会和成员属性冲突

this.name表示当前对象的name属性，与形参列表的name区分开

**this的本质**

==类有一个隐藏属性，指向其本身类的地址空间==

![image-20240814151152450](C:\Users\F\AppData\Roaming\Typora\typora-user-images\image-20240814151152450.png)

> object类中有一个hashCode()方法，返回对象的哈希码值。这通常通过将对象的内部地址转换为整数来实现，使用方法：`p.hashCode()`

哪个对象调用，this就代表哪个对象

1. this关键字可以用来访问本类的属性、方法、构造器
2. this用于区分当前类属性和局部变量
3. 访问成员方法的语法this.方法名(参数列表)==方法名(参数列表)
4. 访问构造器：this(参数列表)；==只能在构造器中使用，只能在构造器中访问另一个构造器，而且要放在第一条语句==
5. this只能在类定义的方法使用，不能在类定义的外部使用

name可能受到局部变量影响，而this.name则不会

> Double是一个类

> Math.PI就是Π

> 任何一个类，都可以有main

> Random类

```
Random r=new Random();
gessnum=r.nextInt(3);//返回0-2的随机整数
```

